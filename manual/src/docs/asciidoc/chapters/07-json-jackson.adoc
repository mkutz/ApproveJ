= JSON with Jackson

ApproveJ provides JSON support via https://github.com/FasterXML/jackson[Jackson] in two modules:

* `json-jackson` for Jackson 2.x
* `json-jackson3` for Jackson 3.x

Both modules provide the same functionality with identical APIs.
Choose the one matching your project's Jackson version.

IMPORTANT: Use only one of these modules in your project, not both.
Both modules register with the same alias `"json"`, and having both on the classpath will cause an error at runtime.

Since Jackson is a provided dependency, you need to add it explicitly.

== Dependencies

=== Jackson 2.x

.Gradle
[source,groovy,subs=attributes+,role="primary"]
----
implementation 'org.approvej:json-jackson:{revnumber}'
implementation 'com.fasterxml.jackson.core:jackson-databind:2.18.0'
implementation 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.18.0'
----
.Gradle.kts
[source,kotlin,subs=attributes+,role="secondary"]
----
implementation("org.approvej:json-jackson:{revnumber}")
implementation("com.fasterxml.jackson.core:jackson-databind:2.18.0")
implementation("com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.18.0")
----
.Maven
[source,xml,subs=attributes+,role="secondary"]
----
<dependency>
  <groupId>org.approvej</groupId>
  <artifactId>json-jackson</artifactId>
  <version>{revnumber}</version>
</dependency>
<dependency>
  <groupId>com.fasterxml.jackson.core</groupId>
  <artifactId>jackson-databind</artifactId>
  <version>2.18.0</version>
</dependency>
<dependency>
  <groupId>com.fasterxml.jackson.datatype</groupId>
  <artifactId>jackson-datatype-jsr310</artifactId>
  <version>2.18.0</version>
</dependency>
----

=== Jackson 3.x

.Gradle
[source,groovy,subs=attributes+,role="primary"]
----
implementation 'org.approvej:json-jackson3:{revnumber}'
implementation 'tools.jackson.core:jackson-databind:3.0.0'
----
.Gradle.kts
[source,kotlin,subs=attributes+,role="secondary"]
----
implementation("org.approvej:json-jackson3:{revnumber}")
implementation("tools.jackson.core:jackson-databind:3.0.0")
----
.Maven
[source,xml,subs=attributes+,role="secondary"]
----
<dependency>
  <groupId>org.approvej</groupId>
  <artifactId>json-jackson3</artifactId>
  <version>{revnumber}</version>
</dependency>
<dependency>
  <groupId>tools.jackson.core</groupId>
  <artifactId>jackson-databind</artifactId>
  <version>3.0.0</version>
</dependency>
----

TIP: If you use the ApproveJ BOM, you can omit the Jackson version numbers as the BOM provides recommended versions.

NOTE: Jackson 3 has Java date/time support built-in, so no separate `jackson-datatype-jsr310` dependency is needed.

=== Import Differences

The API is identical between both modules.
Only the import statements differ:

[cols="1,1"]
|===
| Jackson 2.x | Jackson 3.x

| `org.approvej.json.jackson.*`
| `org.approvej.json.jackson3.*`

| `com.fasterxml.jackson.databind.*`
| `tools.jackson.databind.*`
|===


== Scrub JSON

The link:{javadoc-url}/json-jackson/org/approvej/json/jackson/JsonPointerScrubber.html[`JsonPointerScrubber`] can be used to scrub a JSON node identified by a https://javadoc.io/doc/com.fasterxml.jackson.core/jackson-core/latest/com/fasterxml/jackson/core/JsonPointer.html[`JsonPointer`].

Compared to generic `Scrubber<String>` implementations this is particularly useful when there are several values matching the same pattern, but only one of them needs to be scrubbed.
For instance, if you have a JSON containing two UUIDs, one that was generated by the code (and hence needs to be scrubbed) and one that is a reference to another resource and should not be scrubbed.

[source,java,indent=0,role="primary"]
.Java
----
include::../../../test/java/examples/java/JsonJacksonDocTest.java[tag=scrub_json_pointer]
----
[source,kotlin,indent=0,role="secondary"]
.Kotlin
----
include::../../../test/kotlin/examples/kotlin/JsonJacksonDocTest.kt[tag=scrub_json_pointer]
----
<1> scrubs the dynamically assigned `id` node on the root level of the JSON and replaces it with "[scrubbed id]"
<2> scrubs the `published` timestamp node on the root level of the JSON and replaces it with "[scrubbed published]"
<3> stores the received data at a file next to the test with the file extension `.json`

[source,json]
.Approved file
----
include::../../../test/java/examples/java/JsonJacksonDocTest-scrub_json_pointer-approved.json[]
----


== Pretty Print JSON

In the example above, the JSON persisted in a one-liner.
Even for the simple example, this is not very readable, let alone easily comparable to a slightly different JSON.
To improve this, you can use the link:{javadoc-url}/json-jackson/org/approvej/json/jackson/JsonPrintFormat.html[`JsonPrintFormat`].

[source,java,indent=0,role="primary"]
.Java
----
include::../../../test/java/examples/java/JsonJacksonDocTest.java[tag=pretty_print_json]
----
[source,kotlin,indent=0,role="secondary"]
.Kotlin
----
include::../../../test/kotlin/examples/kotlin/JsonJacksonDocTest.kt[tag=pretty_print_json]
----
<1> applies the `JsonPrintFormat` to convert the `JsonNode` object to a string

Now the approved file is much more readable.

[source,json]
.Approved file
----
include::../../../test/java/examples/java/JsonJacksonDocTest-pretty_print_json-approved.json[]
----


== Pretty Print JSON Strings

It is not necessary to parse the JSON string before printing it.
If the value is a string, `JsonPrintFormat` automatically pretty prints it.
The only downside is, that you can not use JSON-specific scrubbers.

[source,java,indent=0,role="primary"]
.Java
----
include::../../../test/java/examples/java/JsonJacksonDocTest.java[tag=pretty_print_json_string]
----
[source,kotlin,indent=0,role="secondary"]
.Kotlin
----
include::../../../test/kotlin/examples/kotlin/JsonJacksonDocTest.kt[tag=pretty_print_json_string]
----
<1> applies the `JsonPrintFormat` to pretty print the given JSON string

[source,json]
.Approved file
----
include::../../../test/java/examples/java/JsonJacksonDocTest-pretty_print_json_string-approved.json[]
----

Note that the applied scrubbers also replaced the tag IDs.
